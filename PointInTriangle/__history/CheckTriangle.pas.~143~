unit CheckTriangle;

interface

uses
  Windows, Generics.Collections;

type
  TShapeState = (ssIdle, ssSelected);

  TMyPoint = record
  public
    X, Y: Integer;
    class operator Subtract(const Pnt1, Pnt2: TMyPoint): TMyPoint;
    function Dots(const Pnt1, Pnt2: TMyPoint): Extended;
    function Cross(const Pnt1, Pnt2: TMyPoint): Extended;
  end;

  TTriangle = class
  public
    A, B, C: TMyPoint;
  end;

  TMyTriList = class(TList<TTriangle>)
    public
      procedure ClearAndFreeItems;
  end;

  IJudgePointInTri = interface
    function IsTriangle(NewTri: TTriangle): Boolean;
    function PointExist(const PointJudge: TMyPoint; FTriList: TList<TTriangle>): TList<TTriangle>;
    function OnlyPointJudge(const PointJudge: TMyPoint; NewTri: TTriangle): Boolean;
    function CreateTri(TotalTri: Integer): TList<TTriangle>;
  end;

  TCheckPoint = class(TInterfacedObject, IJudgePointInTri)
  public
    function IsTriangle(NewTri: TTriangle): Boolean;
    function PointExist(const PointJudge: TMyPoint; FTriList: TList<TTriangle>): TList<TTriangle>;
    function OnlyPointJudge(const PointJudge: TMyPoint; NewTri: TTriangle): Boolean;
    function CreateTri(TotalTri: Integer): TList<TTriangle>;
    //function PointLine(const PointJudge: TMyPoint; NewTri: TTriangle): Boolean;
  end;

implementation

function TCheckPoint.CreateTri(TotalTri: Integer): TList<TTriangle>;
var
  I: Integer;
  NewTri: TTriangle;
begin
  Result := TList<TTriangle>.Create;
  try
  if TotalTri > 0 then
  begin
    I := 0;
    Randomize;
    while I < TotalTri do
    begin
      NewTri := TTriangle.Create;
      NewTri.A.X := Random(700);
      NewTri.A.Y := Random(700);
      NewTri.B.X := Random(700);
      NewTri.B.Y := Random(700);
      NewTri.C.X := Random(700);
      NewTri.C.Y := Random(700);
      if IsTriangle(NewTri) then
      begin
        Result.Add(NewTri);
        I := I + 1;
      end else
        NewTri.Free;
    end;
  end;
  finally
  end;
end;

function TCheckPoint.IsTriangle(NewTri: TTriangle): Boolean;
const
  Tol = 1E-5;
var
  Line1, Line2, Line3: Double;
begin
   Result := False;
   Line1 := Sqrt(Sqr(NewTri.A.X - NewTri.B.X) + Sqr(NewTri.A.Y - NewTri.B.Y));
   Line2 := Sqrt(Sqr(NewTri.B.X - NewTri.C.X) + Sqr(NewTri.B.Y - NewTri.C.Y));
   Line3 := Sqrt(Sqr(NewTri.C.X - NewTri.A.X) + Sqr(NewTri.C.Y - NewTri.A.Y));
   if (Line1 + Line2 - Line3 > Tol) and (Line2 + Line3 - Line1 > Tol) and
    (Line1 + Line3 - Line2> Tol) then
     Result := True;
end;

function TCheckPoint.OnlyPointJudge(const PointJudge: TMyPoint; NewTri: TTriangle): Boolean;
var
  V0, V1, V2, P: TMyPoint;
  u, v, Deno: Extended;
  obj: TMyPoint;
begin
  Result := False;
  P.X := PointJudge.X;
  P.Y := PointJudge.Y;
  // v0 = C - A, v1 = B - A, v2 = P - A;
  // u = ((v1 x v1)(v2 x v0)-(v1 x v0)(v2 x v1)) / ((v0 x v0)(v1 x v1) - (v0 x v1)(v1 x v0))
  // v = ((v0 x v0)(v2 x v1)-(v0 x v1)(v2 x v0)) / ((v0 x v0)(v1 x v1) - (v0 x v1)(v1 x v0))
  V0 := NewTri.C - NewTri.A;
  V1 := NewTri.B - NewTri.A;
  V2 := P - NewTri.A;
  Deno := obj.Dots(V0, V0) * obj.Dots(V1, V1) - obj.Dots(V0, V1) * obj.Dots(V1, V0);
  u := (obj.Dots(V1, V1) * obj.Dots(V2, V0) - obj.Dots(V1, V0) * obj.Dots(V2, V1)) / Deno;
  v := (obj.Dots(V0, V0) * obj.Dots(V2, V1) - obj.Dots(V0, V1) * obj.Dots(V2, V0)) / Deno;
  if (u >= 0) and (v >= 0) and (u + v <= 1) then
    Result := True;
end;

function TCheckPoint.PointExist(const PointJudge: TMyPoint; FTriList: TList<TTriangle>): TList<TTriangle>;
var
  I, J: Integer;
begin
  Result := TList<TTriangle>.Create;
  for I := 0 to FTriList.Count - 1 do
  begin
    if OnlyPointJudge(PointJudge, FTriList.Items[i]) then
      Result.Add(FTriList[i]);
  end;
end;

{ MyPoint }

function TMyPoint.Cross(const Pnt1, Pnt2: TMyPoint): Extended;
begin
  Result := Pnt1.X * Pnt2.Y - Pnt1.Y * Pnt2.X;
end;

function TMyPoint.Dots(const Pnt1, Pnt2: TMyPoint): Extended;
begin
  Result := Pnt1.X * Pnt2.X + Pnt1.Y * Pnt2.Y;
end;

class operator TMyPoint.Subtract(const Pnt1, Pnt2: TMyPoint): TMyPoint;
begin
  Result.X := Pnt1.X - Pnt2.X;
  Result.Y := Pnt1.Y - Pnt2.Y;
end;

{ TTriangle }

{ TMyTriList }

procedure TMyTriList.ClearAndFreeItems;
var
  I: Integer;
begin
  for I := 0 to Self.Count - 1 do
  begin
    Self[I].Free;
  end;
  Self.Clear;
end;

end.
